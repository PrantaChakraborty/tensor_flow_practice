# -*- coding: utf-8 -*-
"""tensorflow_Basic classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JCeTRA8JIhIQgSOV0p-ww8a95IafJGzk
"""

import tensorflow as tf

import numpy as np
import matplotlib.pyplot as plt

print(tf.__version__)

fashion_mnist = tf.keras.datasets.fashion_mnist

(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()

# assigning labels 
class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

# analyzing the dataset
train_image.shape

train_labels

test_image.shape

len(test_labels)

# preprocess the data
plt.figure()
plt.imshow(train_images[0]) # imshow used to display data as image
plt.colorbar()
plt.grid(True)
plt.show()

# scale the values between 0 to 1
train_images = train_images / 255.0
test_images = test_images / 255.0

# showing some images from the dataset
plt.figure(figsize = (10, 10))
for i in range(10):
  plt.subplot(5,5, i+1)
  plt.xticks([]) # used to get current tick location and labels of the x-axis.
  plt.yticks([])  # used to get current tick location and labels of the y-axis
  plt.grid(False)
  plt.imshow(train_images[i], cmap=plt.cm.binary)
  plt.xlabel(class_names[train_labels[i]])
plt.show()

# build the model
model = tf.keras.Sequential([
      tf.keras.layers.Flatten(input_shape=(28, 28)), #  transforms the format of the images from a two-dimensional array (of 28 by 28 pixels) to a one-dimensional array (of 28 * 28 = 784 pixels).
      tf.keras.layers.Dense(128, activation='relu'), # 128 of densely or fully connected nodes/neurons
      tf.keras.layers.Dense(10) # 10 dense or fully connected neurons/nodes
])

"""
Loss function —This measures how accurate the model is during training. 
You want to minimize this function to "steer" the model in the right direction.
Optimizer —This is how the model is updated based on the data it sees and its loss function.
Metrics —Used to monitor the training and testing steps. The following example uses accuracy, the fraction of the images that are correctly classified.
"""

model.compile(optimizer='adam', 
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

# feed the model
model.fit(train_images, train_labels, epochs=15) # epochs = number of iteration

test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2)

print('\nTest accuracy:', test_acc)

# prediction
probability_model = tf.keras.Sequential([model, tf.keras.layers.Softmax()])

prediction = probability_model.predict(test_images)

prediction[0]

# seeing which label has highest value
np.argmax(prediction[0])

# visualization
def plot_image(i, predictions_array, true_label, img):
  true_label = true_label[i]
  img = img[i]
  plt.grid(False)
  plt.xticks([])
  plt.yticks([])
  plt.imshow(img)
  predicted_label = np.argmax(predictions_array)
  if predicted_label == true_label:
    color = 'blue'
  else:
    color = 'red'
  plt.xlabel("{} {:2.0f}%({})".format(class_names[predicted_label],
                                      100*np.max(predictions_array),
                                      class_names[true_label],
                                      color=color))
  
  # for showing probability using barplot
def plot_value_array(i, predictions_array, true_label):
  true_label = true_label[i]
  plt.grid(False)
  plt.xticks(range(10))
  plt.yticks([])
  thisplot = plt.bar(range(10), predictions_array, color= "#777777")
  plt.ylim([0, 1])
  predicted_label = np.argmax(predictions_array)

  thisplot[predicted_label].set_color('red')
  thisplot[true_label].set_color('green')

# calling the function for visualize
i=50
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i, prediction[i], test_labels, test_images)
plt.subplot(1,2,2)
plot_value_array(i, prediction[i], test_labels)
plt.show()

# Plot the first X test images, their predicted labels, and the true labels.
# Color correct predictions in blue and incorrect predictions in red.
num_rows = 4
num_cols = 2
num_images = num_rows*num_cols
plt.figure(figsize=(2*2*num_cols, 2*num_rows))
for i in range(num_images):
  plt.subplot(num_rows, 2*num_cols, 2*i+1)
  plot_image(i, prediction[i], test_labels, test_images)
  plt.subplot(num_rows, 2*num_cols, 2*i+2)
  plot_value_array(i, prediction[i], test_labels)
plt.tight_layout()
plt.show()

